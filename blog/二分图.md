# 二分图相关算法

假如一张点数至少是2的无向图的节点可以被划分成两个集合，使得每个集合内的点之间没有连边，那么此无向图被称为一张二分图。这两个集合，虽然完全等价，习惯上被称为二分图的左部和右部。一个简单的考虑二分图的方式是，想象有若干男人和女人（均为异性恋），若两人之间互相爱慕则连边。由于所有人均为异性恋，按性别将人划分成两个集合（比如，男左女右），在每个性别的集合内部不存在连边，从而此图是二分图。

## 二分图的判定

判断一张图是否为二分图，一般采取染色法。（但我们如下用的是性别的譬喻，因而似乎可以叫做染色体法。）

首先随机选取一个人，认为他是男人，那么和他存在连边的所有人均为女人。如是递归标记，除非在标记过程中发现某人已经被标记性别，但却和当前正在标记的人具有同样性别且有连边，那么此时显然出现了同性恋或双性恋，因而可判定此图不是二分图。若所有联通块均遍历过并没有产生冲突，则此图是二分图。注意对于每个联通块，第一个人的性别事实上都有两种可能，因而若联通块的个数为$c$，所有可能的染色方案数是$2^c$。

一张图是二分图，当且仅当图中不存在长度为奇数的环。这是显然的。从一个男人出发，按连边行走，则第一步遇到女人、第二步遇到男人、第三步遇到女人……如果走奇数步，遇到的一定是女人，从而不可能是他自己，即不能成环。

## 二分图的最大匹配

”任意两条边都没有公共端点“的边的集合被称为图的一组匹配。假如我们身处一夫一妻制国家，这些男人和女人要（基于爱慕关系）开始结婚，那么所有男女双方步入婚姻殿堂的一个爱慕关系（图中的一条边）构成一个集合。显然这些边两两不能有公共端点，否则这位公共端点将触犯重婚罪。

对于一组匹配，双方结婚的爱慕关系就是匹配边，双方没有结婚的爱慕关系就是非匹配边；已婚人士就是匹配点，单身人士就是非匹配点。对于一张二分图，匹配边数量最多的一组匹配，即最多爱慕关系得以成婚的这组匹配，被称为最大匹配。

考虑从一位单身人士A出发，他有一位爱慕对象B已婚，B的丈夫是C，而C有一位（无疾而终的）爱慕对象D，那是因为D已经和E结婚，而E和F互有好感却留下F单身。我们由此得到了一条路径，这条路径从一位单身人士A出发、到一位单身人士F结束，沿途的每一条边以”成婚”、“未成婚”的方式交替。我们说这种路径是当前匹配的一条增广路。

注意在上述这种情况中，如果我们希望增大婚姻关系数量，完全可以将增广路上的所有边的成婚状态进行翻转。原先只有B和C结婚、D和E结婚，现在我们可以使A和B结婚、C和D结婚、E和F结婚。这样，匹配的定义依然满足，而婚姻关系数量增加了1.

可以证明，当一个图的匹配中不存在增广路时，该匹配是最大匹配。

### 匈牙利算法

考虑如何求二分图的最大匹配。

对于所有男人$x$，开始时单身，我们尝试满足他的一个爱慕关系。考虑所有和他互相爱慕的$y$：

- 如果$y$尚且未婚，那么直接满足；
- 如果$y$不巧已婚，我们先标记$y$，然后尝试给$y$目前的配偶$z$（在所有未标记的点中）满足一个新的爱慕关系。这一步可以递归完成。如果$z$的新的爱慕关系可以满足（也就是说，如果暂时去掉$y$和$z$的婚姻关系，存在一条从$z$开始的增广路——进一步，如果保持$y$和$z$的婚姻关系，存在一条从$x$开始的增广路），那么立即让$z$另寻新欢（事实上增广路上的边的翻转在递归中已经完成）、并撮合$x$和$y$百年好合（直到下一次算法认为应该拆散他们）。

匹配边数也就等于成婚男人的数量。下面这个函数`dfs`返回的是能否给`x`进行一个匹配，我们对所有的`x`遍历，若能就记录答案。

```cpp
bool vis[N];
int match[N];
bool dfs(int x) {
    for (int y: grh[x]) {
        if (!vis[y]) {
            vis[y] = 1;
            if (!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    }
    return false;
}

int ans = 0;
for(int i = 1; i <= n; i++) {
    memset(vis, 0, sizeof(vis));
    if (dfs(i)) ans++;
}
```

